# ğŸª Bookstore Microservices API

Un sistema de microservicios simple para gestionar una librerÃ­a, construido con **NestJS**, **Prisma** y **arquitectura Hexagonal + Clean + DDD**. Incluye dos servicios independientes:

- ğŸ“š **Books Service** â†’ GestiÃ³n de libros.
- ğŸ›’ **Orders Service** â†’ GestiÃ³n de Ã³rdenes, validando libros a travÃ©s del servicio de Books vÃ­a HTTP.

---

## ğŸ“‘ Tabla de Contenidos
- [ğŸ“Œ DescripciÃ³n General](#-descripciÃ³n-general)
- [ğŸ—ï¸ Arquitectura del Sistema](#ï¸-arquitectura-del-sistema)
  - [Estructura de los microservicios] (#-estructura-de-los-microservicios)
  - [Diagramas Mermaid] (#-diagramas-mermaid)
- [ğŸ§° TecnologÃ­as](#-tecnologÃ­as)
- [âš™ï¸ Requisitos Previos](#-requisitos-previos)
- [ğŸš€ InstalaciÃ³n & EjecuciÃ³n](#-instalaciÃ³n--ejecuciÃ³n)
  - [Docker Compose](#-docker-compose)
  - [EjecuciÃ³n local](#-ejecuciÃ³n-local)
- [ğŸ“¦ Dependencias](#-dependencias)
- [ğŸ“ Endpoints Principales](#-endpoints-principales)
- [ğŸ› ï¸ Decisiones de Arquitectura](#-decisiones-de-arquitectura)
- [Autor](#-autor)
- [Licencia](#-licencia)

---

## ğŸ“Œ DescripciÃ³n General

Este sistema implementa dos microservicios independientes que se comunican vÃ­a **HTTP** siguiendo principios de **arquitectura de microservicios**:

- **Books Service** â†’ permite crear, leer y buscar libros.
- **Orders Service** â†’ permite crear y listar Ã³rdenes. Antes de crear una orden, valida la existencia del libro llamando al Books Service.

Cada servicio tiene **su propio schema en una base de datos compartida** y no acceden a los schemas de otros servicios.

---

## ğŸ—ï¸ Arquitectura del Sistema

### ğŸ“‚ Estructura de directorios

```
.
â”œâ”€â”€ books-service/        # Microservicio de libros
â”œâ”€â”€ orders-service/       # Microservicio de Ã³rdenes
â”œâ”€â”€ docker-compose.yml    # OrquestaciÃ³n de servicios
â””â”€â”€ README.md             # DocumentaciÃ³n raÃ­z
```

### ğŸŒ Diagrama de microservicios

```mermaid
flowchart LR
    subgraph Client[Cliente / Frontend]
      UI[UI / Swagger / cURL]
    end

    subgraph Books[ğŸ“š Books Service]
      BC[BookController]
      BU[UseCases]
      BR[BookRepository]
    end

    subgraph Orders[ğŸ›’ Orders Service]
      OC[OrderController]
      OU[UseCases]
      OR[OrderRepository]
    end

    subgraph DB[(PostgreSQL - Base de Datos Compartida)]
      DBS1[(Schema: books)]
      DBS2[(Schema: orders)]
    end

    UI -->|HTTP| BC
    UI -->|HTTP| OC

    OC -->|HTTP /books/:id| BC

    BR --> DBS1
    OR --> DBS2
```

### âš™ï¸ Flujo de creaciÃ³n de una orden

```mermaid
sequenceDiagram
  participant Client
  participant OrdersAPI as Orders Service
  participant BooksAPI as Books Service
  participant DB as PostgreSQL (DB Compartida)

  Client->>OrdersAPI: POST /orders { bookId, quantity }
  OrdersAPI->>BooksAPI: GET /books/:id
  alt Libro encontrado
      BooksAPI-->>OrdersAPI: 200 OK + Book Data
      OrdersAPI->>DB: INSERT INTO orders schema
      DB-->>OrdersAPI: Saved
      OrdersAPI-->>Client: 201 Created (Order)
  else Libro no existe
      BooksAPI-->>OrdersAPI: 404 Not Found
      OrdersAPI-->>Client: 404 Book Not Found
  end
```

---

## âš™ï¸ Requisitos Previos

- Node.js v22
- Docker & Docker Compose
- PostgreSQL (opcional si no usas Docker)

---

## ğŸš€ InstalaciÃ³n & EjecuciÃ³n

1. Clona el repositorio junto a sus submÃ³dulos y entra al directorio:

   ```bash
   git clone --recurse-submodules git@github.com:SebastianBC09/Bookstore-microservice-system.git
   cd Bookstore-microservice-system
   ```


### ğŸ³ Docker Compose

Levantar con:

```bash
docker-compose up --build
```

### ğŸ’» EjecuciÃ³n local (sin Docker)

1. Levantar cada servicio (`npm run start:dev` en cada carpeta).
2. Configurar `.env` en cada microservicio con `DATABASE_URL` y puertos.

---

## ğŸ“ Endpoints Principales

### Books Service
- `GET /books`
- `GET /books/:id`
- `POST /books`

### Orders Service
- `GET /orders`
- `POST /orders`

---

## ğŸ› ï¸ Decisiones de Arquitectura

- **Arquitectura Hexagonal**: separaciÃ³n clara entre `domain`, `application`, `infrastructure` e `interfaces`.
- **ComunicaciÃ³n HTTP**: los servicios se comunican vÃ­a REST, nunca a traves de la DB.
- **Errores de dominio**: clases especÃ­ficas (`BookNotFoundError`, `BooksServiceUnavailableError`, etc.) mapeadas a cÃ³digos HTTP.
- **Prisma como infraestructura**: nunca se expone fuera de la capa infra.
- **Swagger en cada servicio**: documentaciÃ³n accesible en `/api`.

---

## ğŸ‘¨â€ğŸ’» Autor

**Sebastian Ballen C** - _FullStack Developer_

- LinkedIn: [Sebastian B.](https://www.linkedin.com/in/sebastianballencastaneda-softwaredeveloper)
- Email: sebastian.ballenc@gmail.com

---

## ğŸ“„ Licencia

Este proyecto estÃ¡ licenciado bajo la Licencia MIT - vea el archivo [LICENSE](LICENSE) para mÃ¡s detalles.

---

â­ï¸ **Si te resulta Ãºtil este proyecto, Â¡no olvides darle una estrella en GitHub!** â­ï¸
